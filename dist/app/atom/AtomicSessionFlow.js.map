{"version":3,"sources":["app/atom/AtomicSessionFlow.ts"],"names":[],"mappings":"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","file":"AtomicSessionFlow.js","sourcesContent":["import { transaction } from 'objection';\r\nimport { MinorException } from 'back-lib-common-util';\r\nimport { AtomicSession } from 'back-lib-common-contracts';\r\n\r\nimport { IDatabaseConnector, KnexConnection } from '../connector/IDatabaseConnector';\r\n\r\n\r\nexport type SessionTask = (session: AtomicSession, previousOutput?: any) => Promise<any>;\r\n\r\n/**\r\n * Provides method to execute queries on many database connections, but still make\r\n * sure those queries are wrapped in transactions.\r\n */\r\nexport class AtomicSessionFlow {\r\n\r\n\tprivate _sessions: AtomicSession[];\r\n\tprivate _tasks: SessionTask[];\r\n\tprivate _initPromise: Promise<any[]>;\r\n\tprivate _finalPromise: Promise<any>;\r\n\tprivate _abortFn: (reason) => void;\r\n\r\n\t/**\r\n\t * \r\n\t * @param {string[]} names Only executes the queries on connections with specified names.\r\n\t */\r\n\tconstructor(protected _dbConnector: IDatabaseConnector, names: string[]) {\r\n\t\tthis._sessions = [];\r\n\t\tthis._tasks = [];\r\n\t\tthis.initSessions(names);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if it is possible to call \"pipe()\".\r\n\t */\r\n\tpublic get isPipeClosed(): boolean {\r\n\t\treturn (this._finalPromise != null);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a promise which resolves to the output of the last query\r\n\t * on primary (first) connection.\r\n\t * This method must be called at the end of the pipe chain.\r\n\t */\r\n\tpublic closePipe(): Promise<any> {\r\n\t\tif (!this.isPipeClosed) {\r\n\t\t\tthis._finalPromise = new Promise(async (resolve, reject) => {\r\n\t\t\t\tthis._abortFn = reject;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet transPromises = await this._initPromise;\r\n\t\t\t\t\t// Clean up\r\n\t\t\t\t\tthis._initPromise = null;\r\n\r\n\t\t\t\t\t// Start executing enqueued tasks\r\n\t\t\t\t\tthis.loop();\r\n\r\n\t\t\t\t\t// Waits for all transaction to complete,\r\n\t\t\t\t\t// but only takes output from primary (first) one.\r\n\t\t\t\t\t// `transPromises` resolves when `resolveAllTransactions` is called,\r\n\t\t\t\t\t// and reject when ``rejectAllTransactions()` is called.\r\n\t\t\t\t\tlet outputs = await Promise.all(transPromises);\r\n\t\t\t\t\tresolve(outputs[0]);\r\n\t\t\t\t}\r\n\t\t\t\t// Error on init transaction\r\n\t\t\t\tcatch (err) { reject(err); }\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn this._finalPromise;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a task to session, it will be executed inside transaction of each connections\r\n\t * This method is chainable and can only be called before `closePipe()` is invoked.\r\n\t */\r\n\tpublic pipe(task: SessionTask): AtomicSessionFlow {\r\n\t\tif (this.isPipeClosed) {\r\n\t\t\tthrow new MinorException('Pipe has been closed!');\r\n\t\t}\r\n\r\n\t\tthis._tasks.push(task);\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\tprivate initSessions(names: string[]): Promise<any[]> {\r\n\t\treturn this._initPromise = new Promise<any[]>((resolveInit, rejectInit) => {\r\n\t\t\tlet transPromises = [],\r\n\t\t\t\tconns: KnexConnection[] = this._dbConnector.connections,\r\n\t\t\t\tlen = conns.length,\r\n\t\t\t\ti = 0;\r\n\r\n\t\t\t// Start a new transaction for each connection.\r\n\t\t\tfor (let knexConn of conns) {\r\n\t\t\t\tif (names && names.length && !names.includes(knexConn.customName)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// `transPro` resolves when transaction is commited. Otherwise, it rejects.\r\n\t\t\t\tlet transPro: Promise<any> = transaction(knexConn, trans => {\r\n\t\t\t\t\tthis._sessions.push(new AtomicSession(knexConn, trans));\r\n\r\n\t\t\t\t\ti++;\r\n\t\t\t\t\t// Last connection\r\n\t\t\t\t\tif (i == len || (names && names.length && i == names.length)) {\r\n\t\t\t\t\t\tresolveInit(transPromises);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t});\r\n\t\t\t\ttransPromises.push(transPro);\r\n\t\t\t} // END for\r\n\t\t\tif (!transPromises.length) {\r\n\t\t\t\trejectInit(new MinorException('No transaction was created!'));\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tprivate doTask(prevOutputs: any[]): Promise<any[]> {\r\n\t\tlet task = this._tasks.shift();\r\n\t\tprevOutputs = prevOutputs || [];\r\n\r\n\t\tif (!task) {\r\n\t\t\t// When there's no more task, we commit all transactions.\r\n\t\t\tthis.resolveAllTransactions(prevOutputs);\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn this.collectTasksOutputs(task, prevOutputs);\r\n\t}\r\n\r\n\tprivate collectTasksOutputs(task, prevOutputs): Promise<any> {\r\n\t\t// Unlike Promise.all(), this promise collects all query errors.\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\tlet i = 0,\r\n\t\t\t\tsessions = this._sessions,\r\n\t\t\t\tsLen = sessions.length,\r\n\t\t\t\tresults = [],\r\n\t\t\t\terrors = [];\r\n\r\n\t\t\t// Execute each task on all sessions (transactions).\r\n\t\t\tfor (let s of sessions) {\r\n\t\t\t\ttask.call(null, s, prevOutputs[i])\r\n\t\t\t\t\t.then(r => {\r\n\t\t\t\t\t\t// Collect results\r\n\t\t\t\t\t\tresults.push(r);\r\n\t\t\t\t\t\tif (++i == sLen) {\r\n\t\t\t\t\t\t\t// If there is at least one error,\r\n\t\t\t\t\t\t\t// all transactions are marked as failure.\r\n\t\t\t\t\t\t\tif (errors.length) {\r\n\t\t\t\t\t\t\t\t/* istanbul ignore next */\r\n\t\t\t\t\t\t\t\treject(errors.length == 1 ? errors[0] : errors);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// All transactions are marked as success\r\n\t\t\t\t\t\t\t\t// only when all of them finish without error.\r\n\t\t\t\t\t\t\t\tresolve(results);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.catch(er => {\r\n\t\t\t\t\t\terrors.push(er);\r\n\t\t\t\t\t\t// Collect error from all queries.\r\n\t\t\t\t\t\tif (++i == sLen) {\r\n\t\t\t\t\t\t\t/* istanbul ignore next */\r\n\t\t\t\t\t\t\treject(errors.length == 1 ? errors[0] : errors);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t} // END for\r\n\t\t});\r\n\t}\r\n\r\n\tprivate loop(prevOutputs?: any[]): Promise<void> {\r\n\t\tlet prevWorks = this.doTask(prevOutputs);\r\n\t\tif (!prevWorks) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tprevWorks\r\n\t\t\t.then(prev => {\r\n\t\t\t\tthis.loop(prev);\r\n\t\t\t})\r\n\t\t\t.catch(err => this.rejectAllTransactions(err))\r\n\t\t\t// This catches both promise errors and AtomicSessionFlow's errors.\r\n\t\t\t.catch(this._abortFn);\r\n\t}\r\n\r\n\tprivate resolveAllTransactions(outputs): void {\r\n\t\tthis._sessions.forEach((s, i) => s.knexTransaction.commit(outputs[i]));\r\n\t\tthis._sessions = this._tasks = null; // Clean up\r\n\t}\r\n\r\n\tprivate rejectAllTransactions(error): void {\r\n\t\tthis._sessions.forEach(s => s.knexTransaction.rollback(error));\r\n\t}\r\n}"]}