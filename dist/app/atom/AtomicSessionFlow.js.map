{"version":3,"sources":["app/atom/AtomicSessionFlow.ts"],"names":[],"mappings":"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","file":"AtomicSessionFlow.js","sourcesContent":["import { transaction } from 'objection';\r\nimport { MinorException } from 'back-lib-common-util';\r\nimport { AtomicSession } from 'back-lib-common-contracts';\r\n\r\nimport { IDatabaseConnector, KnexConnection } from '../connector/IDatabaseConnector';\r\n\r\n\r\nexport type SessionTask = (session: AtomicSession, previousOutputs?: any[]) => Promise<any>;\r\n\r\n/**\r\n * Provides method to execute queries on many database connections, but still make\r\n * sure those queries are wrapped in transactions.\r\n */\r\nexport class AtomicSessionFlow {\r\n\r\n\tprivate _sessions: AtomicSession[];\r\n\tprivate _tasks: SessionTask[];\r\n\tprivate _initPromise: Promise<any[]>;\r\n\tprivate _finalPromise: Promise<any>;\r\n\r\n\t/**\r\n\t * \r\n\t * @param {string[]} names Only executes the queries on connections with specified names.\r\n\t */\r\n\tconstructor(protected _dbConnector: IDatabaseConnector, names: string[]) {\r\n\t\tthis._sessions = [];\r\n\t\tthis._tasks = [];\r\n\t\tthis.initSessions(names);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if it is possible to call \"pipe()\".\r\n\t */\r\n\tpublic get isPipeClosed(): boolean {\r\n\t\treturn (this._finalPromise != null);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a promise which resolves to the output of the last query\r\n\t * on primary (first) connection.\r\n\t * This method must be called at the end of the pipe chain.\r\n\t */\r\n\tpublic closePipe(): Promise<any> {\r\n\t\tif (!this.isPipeClosed) {\r\n\t\t\tthis._finalPromise = this._initPromise\r\n\t\t\t\t.then(transPromises => {\r\n\t\t\t\t\t// Clean up\r\n\t\t\t\t\tthis._initPromise = null;\r\n\r\n\t\t\t\t\tlet finalPromise = Promise.all(transPromises)\r\n\t\t\t\t\t\t.then(outputs => outputs[0]);\r\n\r\n\t\t\t\t\t// Wrap in an array to pass to next \"then\",\r\n\t\t\t\t\t// as we don't want to wait for it now.\r\n\t\t\t\t\treturn [finalPromise];\r\n\t\t\t\t})\r\n\t\t\t\t.then(([finalPromise]) => {\r\n\t\t\t\t\tthis.loop();\r\n\t\t\t\t\treturn finalPromise;\r\n\t\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn this._finalPromise;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a task to session, it will be executed inside transaction of each connections\r\n\t * This method is chainable and can only be called before `closePipe()` is invoked.\r\n\t */\r\n\tpublic pipe(task: SessionTask): AtomicSessionFlow {\r\n\t\tif (this.isPipeClosed) {\r\n\t\t\tthrow new MinorException('Pipe has been closed!');\r\n\t\t}\r\n\r\n\t\tthis._tasks.push(task);\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\tprivate initSessions(names: string[]): Promise<any[]> {\r\n\t\treturn this._initPromise = new Promise<any[]>(resolveInit => {\r\n\t\t\tlet transPromises = [],\r\n\t\t\t\tconns: KnexConnection[] = this._dbConnector.connections,\r\n\t\t\t\tlen = conns.length,\r\n\t\t\t\ti = 0;\r\n\r\n\t\t\t// For each connection, we start a new transaction.\r\n\t\t\tconns.forEach(knexConn => {\r\n\t\t\t\tif (names && names.length && !names.includes(knexConn.customName)) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttransaction(knexConn, trans => {\r\n\t\t\t\t\tlet promise = this.wrapTransaction(knexConn, trans);\r\n\t\t\t\t\ttransPromises.push(promise);\r\n\r\n\t\t\t\t\ti++;\r\n\t\t\t\t\t// Last connection\r\n\t\t\t\t\tif (i == len) {\r\n\t\t\t\t\t\tresolveInit(transPromises);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Transaction is commited if this promise resolves.\r\n\t\t\t\t\t// Otherwise, it is rolled back.\r\n\t\t\t\t\t// This is how ObjectionJS transaction works.\r\n\t\t\t\t\treturn promise;\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\tprivate wrapTransaction(knexConn, knexTrans): Promise<any> {\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\t\tthis._sessions.push(new AtomicSession(knexConn, knexTrans, resolve, reject));\r\n\t\t\t})\r\n\t\t\t.catch(err => this.rejectAllTransactions(err));\r\n\t}\r\n\r\n\tprivate loop(prevOutputs?: any[]): Promise<void> {\r\n\t\tlet prevWorks = this.doTask(prevOutputs);\r\n\t\tif (!prevWorks) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tprevWorks\r\n\t\t\t.then(prev => {\r\n\t\t\t\tthis.loop(prev);\r\n\t\t\t})\r\n\t\t\t.catch(err => this.rejectAllTransactions(err));\r\n\t}\r\n\r\n\tprivate doTask(prevOutputs: any[]): Promise<any[]> {\r\n\t\tlet task = this._tasks.shift();\r\n\t\tprevOutputs = prevOutputs || [];\r\n\t\t\r\n\t\tif (!task) {\r\n\t\t\t// When there's no more task, we commit all transactions.\r\n\t\t\tthis._sessions.forEach((s, i) => s.resolve(prevOutputs[i]));\r\n\t\t\tthis._sessions = this._tasks = null; // Clean up\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// Execute each task on all connections (transactions).\r\n\t\treturn Promise.all(\r\n\t\t\tthis._sessions.map((s, i) => task(s, prevOutputs[i]))\r\n\t\t);\r\n\t}\r\n\r\n\tprivate rejectAllTransactions(error) {\r\n\t\tthis._sessions.forEach(s => s.reject(error));\r\n\t\treturn Promise.reject(error);\r\n\t}\r\n}"]}