{"version":3,"sources":["app/atom/AtomicSessionFlow.ts"],"names":[],"mappings":"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","file":"AtomicSessionFlow.js","sourcesContent":["import { transaction } from 'objection';\r\nimport { MinorException } from '@micro-fleet/common-util';\r\nimport { AtomicSession } from '@micro-fleet/common-contracts';\r\n\r\nimport { IDatabaseConnector, KnexConnection } from '../connector/IDatabaseConnector';\r\n\r\n\r\nexport type SessionTask = (session: AtomicSession, previousOutput?: any) => Promise<any>;\r\n\r\n/**\r\n * Provides method to execute queries on many database connections, but still make\r\n * sure those queries are wrapped in transactions.\r\n */\r\nexport class AtomicSessionFlow {\r\n\r\n\tprivate _session: AtomicSession;\r\n\tprivate _tasks: SessionTask[];\r\n\tprivate _initPromise: Promise<any>;\r\n\tprivate _finalPromise: Promise<any>;\r\n\tprivate _abortFn: (reason) => void;\r\n\r\n\t/**\r\n\t * \r\n\t * @param {string[]} names Only executes the queries on connections with specified names.\r\n\t */\r\n\tconstructor(protected _dbConnector: IDatabaseConnector, names: string[]) {\r\n\t\tthis._tasks = [];\r\n\t\tthis.initSession();\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if it is possible to call \"pipe()\".\r\n\t */\r\n\tpublic get isPipeClosed(): boolean {\r\n\t\treturn (this._finalPromise != null);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a promise which resolves to the output of the last query\r\n\t * on primary (first) connection.\r\n\t * This method must be called at the end of the pipe chain.\r\n\t */\r\n\tpublic closePipe(): Promise<any> {\r\n\t\tif (!this.isPipeClosed) {\r\n\t\t\tthis._finalPromise = new Promise(async (resolve, reject) => {\r\n\t\t\t\tthis._abortFn = reject;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet transPromises = await this._initPromise;\r\n\t\t\t\t\t// Clean up\r\n\t\t\t\t\tthis._initPromise = null;\r\n\r\n\t\t\t\t\t// Start executing enqueued tasks\r\n\t\t\t\t\tthis.loop();\r\n\r\n\t\t\t\t\t// Waits for all transaction to complete,\r\n\t\t\t\t\t// but only takes output from primary (first) one.\r\n\t\t\t\t\t// `transPromises` resolves when `resolveAllTransactions` is called,\r\n\t\t\t\t\t// and reject when ``rejectAllTransactions()` is called.\r\n\t\t\t\t\tlet outputs = await Promise.all(transPromises);\r\n\t\t\t\t\tresolve(outputs[0]);\r\n\t\t\t\t}\r\n\t\t\t\t// Error on init transaction\r\n\t\t\t\tcatch (err) { reject(err); }\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn this._finalPromise;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a task to be executed inside transaction.\r\n\t * This method is chainable and can only be called before `closePipe()` is invoked.\r\n\t */\r\n\tpublic pipe(task: SessionTask): AtomicSessionFlow {\r\n\t\tif (this.isPipeClosed) {\r\n\t\t\tthrow new MinorException('Pipe has been closed!');\r\n\t\t}\r\n\r\n\t\tthis._tasks.push(task);\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\tprivate initSession(): Promise<any[]> {\r\n\t\tconst knexConn = this._dbConnector.connection;\r\n\t\treturn this._initPromise = transaction(knexConn, trans => {\r\n\t\t\tthis._session = new AtomicSession(knexConn, trans);\r\n\t\t\treturn null;\r\n\t\t});\r\n\t}\r\n\r\n\tprivate doTask(prevOutput): Promise<any[]> {\r\n\t\tlet task = this._tasks.shift();\r\n\t\tprevOutput = prevOutput || [];\r\n\r\n\t\tif (!task) {\r\n\t\t\t// When there's no more task, we commit all transactions.\r\n\t\t\tthis.resolveTransactions(prevOutput);\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// return this.collectTasksOutputs(task, prevOutputs);\r\n\t\treturn task(this._session, prevOutput);\r\n\t}\r\n\r\n\t/*\r\n\tprivate collectTasksOutputs(task, prevOutputs): Promise<any> {\r\n\t\t// Unlike Promise.all(), this promise collects all query errors.\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\tlet i = 0,\r\n\t\t\t\tsession = this._session,\r\n\t\t\t\tresults = [],\r\n\t\t\t\terrors = [];\r\n\r\n\t\t\t// Execute each task on all sessions (transactions).\r\n\t\t\t// for (let s of sessions) {\r\n\t\t\t\ttask.call(null, this._session, prevOutputs[i])\r\n\t\t\t\t\t.then(r => {\r\n\t\t\t\t\t\t// Collect results\r\n\t\t\t\t\t\tresults.push(r);\r\n\t\t\t\t\t\tif (++i == sLen) {\r\n\t\t\t\t\t\t\t// If there is at least one error,\r\n\t\t\t\t\t\t\t// all transactions are marked as failure.\r\n\t\t\t\t\t\t\tif (errors.length) {\r\n\t\t\t\t\t\t\t\treject(errors.length == 1 ? errors[0] : errors);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// All transactions are marked as success\r\n\t\t\t\t\t\t\t\t// only when all of them finish without error.\r\n\t\t\t\t\t\t\t\tresolve(results);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.catch(er => {\r\n\t\t\t\t\t\terrors.push(er);\r\n\t\t\t\t\t\t// Collect error from all queries.\r\n\t\t\t\t\t\tif (++i == sLen) {\r\n\t\t\t\t\t\t\treject(errors.length == 1 ? errors[0] : errors);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t});\r\n\t}\r\n\t//*/\r\n\r\n\tprivate loop(prevOutput?): Promise<void> {\r\n\t\tlet prevWorks = this.doTask(prevOutput);\r\n\t\tif (!prevWorks) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tprevWorks\r\n\t\t\t.then(prev => {\r\n\t\t\t\tthis.loop(prev);\r\n\t\t\t})\r\n\t\t\t.catch(err => this.rejectTransactions(err))\r\n\t\t\t// This catches both promise errors and AtomicSessionFlow's errors.\r\n\t\t\t.catch(this._abortFn);\r\n\t}\r\n\r\n\tprivate resolveTransactions(output): void {\r\n\t\tthis._session.knexTransaction.commit(output);\r\n\t\tthis._session = this._tasks = null; // Clean up\r\n\t}\r\n\t\r\n\tprivate rejectTransactions(error): void {\r\n\t\tthis._session.knexTransaction.rollback(error);\r\n\t\tthis._session = this._tasks = null; // Clean up\r\n\t}\r\n}"]}