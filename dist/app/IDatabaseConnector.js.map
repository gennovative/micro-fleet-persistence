{"version":3,"sources":["app/IDatabaseConnector.ts"],"names":[],"mappings":";;AAEA;;GAEG;AACH;;AACC;;GAEG;AACoB,cAAK,GAAG,OAAO,CAAC;AAEvC;;GAEG;AACoB,cAAK,GAAG,OAAO,CAAC;AAEvC;;GAEG;AACoB,mBAAU,GAAG,IAAI,CAAC;AAEzC;;GAEG;AACoB,gBAAO,GAAG,SAAS,CAAC;AAnB5C,4BAoBC","file":"IDatabaseConnector.js","sourcesContent":["import { QueryBuilder } from 'objection';\r\n\r\n/**\r\n * Db driver names for `IConnectionDetail.clientName` property.\r\n */\r\nexport class DbClient {\r\n\t/**\r\n\t * Microsoft SQL Server\r\n\t */\r\n\tpublic static readonly MSSQL = 'mssql';\r\n\t\r\n\t/**\r\n\t * MySQL\r\n\t */\r\n\tpublic static readonly MYSQL = 'mysql';\r\n\t\r\n\t/**\r\n\t * PostgreSQL\r\n\t */\r\n\tpublic static readonly POSTGRESQL = 'pg';\r\n\t\r\n\t/**\r\n\t * SQLite 3\r\n\t */\r\n\tpublic static readonly SQLITE3 = 'sqlite3';\r\n}\r\n\r\n/**\r\n * Stores a database connection detail.\r\n */\r\nexport interface IConnectionDetail {\r\n\t/**\r\n\t * Database driver name, should use constants in class DbClient. \r\n\t * Eg: DbClient.SQLITE3, DbClient.POSTGRESQL, ...\r\n\t */\r\n\tclientName: string;\r\n\r\n\t/**\r\n\t * Connection string for specified `clientName`.\r\n\t */\r\n\tconnectionString?: string;\r\n\r\n\t/**\r\n\t * Absolute path to database file name.\r\n\t */\r\n\tfileName?: string;\r\n\r\n\thost?: {\r\n\t\t/**\r\n\t\t * IP Address or Host name.\r\n\t\t */\r\n\t\taddress: string,\r\n\r\n\t\t/**\r\n\t\t * Username to login database.\r\n\t\t */\r\n\t\tuser: string,\r\n\r\n\t\t/**\r\n\t\t * Password to login database.\r\n\t\t */\r\n\t\tpassword: string,\r\n\r\n\t\t/**\r\n\t\t * Database name.\r\n\t\t */\r\n\t\tdatabase: string\r\n\t};\r\n}\r\n\r\n/**\r\n * Invoked when a request for getting query is replied.\r\n * @param queryBuilder {QueryBuilder} A query that is bound to a connection.\r\n * @param boundEntityClass {Class extends Model} A class that is bound to a connection.\r\n */\r\nexport type QueryCallback<TEntity> = (queryBuilder: QueryBuilder<TEntity>, boundEntityClass?) => Promise<any>;\r\n\r\n/**\r\n * Helps with managing multiple database connections and executing same query with all\r\n * of those connections.\r\n */\r\nexport interface IDatabaseConnector {\r\n\t/**\r\n\t * Makes a new database connection to managed list.\r\n\t * @param detail {IConnectionDetail} Credentials to make connection.\r\n\t * @param name {string} Optionally give a name to the connection, for later reference.\r\n\t */\r\n\taddConnection(detail: IConnectionDetail, name?: string): void;\r\n\r\n\t/**\r\n\t * Closes all connections and destroys this connector.\r\n\t */\r\n\tdispose(): Promise<void>;\r\n\t\r\n\t/**\r\n\t * Executes same query on all managed connections. This connector binds connections \r\n\t * to `EntityClass` and passes a queryable instance to `callback`.\r\n\t * \r\n\t * @param EntityClass {Class} An entity class to bind a connection.\r\n\t * @param callback {QueryCallback} A callback to invoke each time a connection is bound.\r\n\t * @param names {string[]} Optionally filter out and only execute query on connections with specified name,\r\n\t * \tif not given, the position index of connection in the managed list will be assigned as name.\r\n\t * @example\r\n\t * \t// Must add at least one connection.\r\n\t * \tconnector.addConnection({...});\r\n\t * \r\n\t * \t// Executes same query on all connections.\r\n\t * \tlet promises = connector.query(AccountEntity, (query) => {\r\n\t * \t\treturn query.insert({ name: 'Example' })\r\n\t * \t});\r\n\t * \r\n\t * \t// Waits for operations on all connections to complete.\r\n\t * \tlet results = await Promise.all(promises);\r\n\t * \r\n\t * \t// Only waits for the primary connection that we care most.\r\n\t * \tlet result = await promises[0];\r\n\t * @return {Promise[]} An array of promises returned by all above callbacks.\r\n\t */\r\n\tquery<TEntity>(EntityClass, callback: QueryCallback<TEntity>, ...names: string[]): Promise<any>[];\r\n}\r\n"]}